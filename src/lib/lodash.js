import lodash from "lodash";
import {rdSet} from "@lib/redis";

/**
 *
 * @type {{<TrapAny extends {__trapAny: any}>(value: TrapAny): (Collection<any> & Function<any> & Object<any> & Primitive<any> & String), <T extends null | undefined>(value: T): Primitive<T>, (value: (string | null | undefined)): String, <T extends (...args: any) => any>(value: T): Function<T>, <T=any>(value: (List<T> | null | undefined)): Collection<T>, <T extends object>(value: (T | null | undefined)): Object<T>, <T>(value: T): Primitive<T>, isBuffer?(value?: any): boolean, xorWith?: {<T>(arrays: (List<T> | null | undefined), comparator?: Comparator<T>): T[], <T>(arrays: (List<T> | null | undefined), arrays2: (List<T> | null | undefined), comparator?: Comparator<T>): T[], <T>(arrays: (List<T> | null | undefined), arrays2: (List<T> | null | undefined), arrays3: (List<T> | null | undefined), ...comparator: Comparator<T> | List<T> | null | undefined[]): T[]}, functions?(object: any): string[], isTypedArray?(value: any): boolean, takeWhile?<T>(array: (List<T> | null | undefined), predicate?: ListIteratee<T>): T[], without?<T>(array: (List<T> | null | undefined), ...values: T[]): T[], toLength?(value: any): number, debounce?: {<T extends (...args: any) => any>(func: T, wait: (number | undefined), options: DebounceSettingsLeading): DebouncedFuncLeading<T>, <T extends (...args: any) => any>(func: T, wait?: number, options?: DebounceSettings): DebouncedFunc<T>}, bind?: FunctionBind, trim?: {(string?: string, chars?: string): string, (string: string, index: (string | number), guard: object): string}, pick?: {<T extends object, U extends keyof T>(object: T, ...props: Many<U>): Pick<T, U>, <T>(object: (T | null | undefined), ...props: Many<PropertyPath>): PartialObject<T>}, valuesIn?: {<T>(object: (Dictionary<T> | NumericDictionary<T> | List<T> | null | undefined)): T[], <T extends object>(object: (T | null | undefined)): Array<T[keyof T]>}, merge?: {<TObject, TSource>(object: TObject, source: TSource): (TObject & TSource), <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): (TObject & TSource1 & TSource2), <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): (TObject & TSource1 & TSource2 & TSource3), <TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): (TObject & TSource1 & TSource2 & TSource3 & TSource4), (object: any, ...otherArgs: any[]): any}, setWith?: {<T extends object>(object: T, path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): T, <T extends object, TResult>(object: T, path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): TResult}, stubString?(): string, sortBy?: {<T>(collection: (List<T> | null | undefined), ...iteratees: Many<ListIteratee<T>>): T[], <T extends object>(collection: (T | null | undefined), ...iteratees: Many<ObjectIteratee<T>>): Array<T[keyof T]>}, eachRight?: {<T>(collection: T[], iteratee?: ArrayIterator<T, any>): T[], (collection: string, iteratee?: StringIterator<any>): string, <T>(collection: List<T>, iteratee?: ListIterator<T, any>): List<T>, <T extends object>(collection: T, iteratee?: ObjectIterator<T, any>): T, <T, TArray extends T[] | null | undefined>(collection: ((TArray & T[]) | (TArray & null) | (TArray & undefined)), iteratee?: ArrayIterator<T, any>): TArray, <TString extends string | null | undefined>(collection: TString, iteratee?: StringIterator<any>): TString, <T, TList extends List<T> | null | undefined>(collection: ((TList & List<T>) | (TList & null) | (TList & undefined)), iteratee?: ListIterator<T, any>): TList, <T extends object>(collection: (T | null | undefined), iteratee?: ObjectIterator<T, any>): (T | null | undefined)}, defaultsDeep?(object: any, ...sources: any[]): any, forIn?: {<T>(object: T, iteratee?: ObjectIterator<T, any>): T, <T>(object: (T | null | undefined), iteratee?: ObjectIterator<T, any>): (T | null | undefined)}, unionWith?: {<T>(arrays: (List<T> | null | undefined), comparator?: Comparator<T>): T[], <T>(arrays: (List<T> | null | undefined), arrays2: (List<T> | null | undefined), comparator?: Comparator<T>): T[], <T>(arrays: (List<T> | null | undefined), arrays2: (List<T> | null | undefined), arrays3: (List<T> | null | undefined), ...comparator: Comparator<T> | List<T> | null | undefined[]): T[]}, isObject?(value?: any): value is object, isSymbol?(value: any): value is symbol, isFunction?(value: any): value is (...args: any[]) => any, isElement?(value?: any): boolean, subtract?(minuend: number, subtrahend: number): number, concat?<T>(...values: Many<T>): T[], capitalize?(string?: string): string, each?: {<T>(collection: T[], iteratee?: ArrayIterator<T, any>): T[], (collection: string, iteratee?: StringIterator<any>): string, <T>(collection: List<T>, iteratee?: ListIterator<T, any>): List<T>, <T extends object>(collection: T, iteratee?: ObjectIterator<T, any>): T, <T, TArray extends T[] | null | undefined>(collection: ((TArray & T[]) | (TArray & null) | (TArray & undefined)), iteratee?: ArrayIterator<T, any>): TArray, <TString extends string | null | undefined>(collection: TString, iteratee?: StringIterator<any>): TString, <T, TList extends List<T> | null | undefined>(collection: ((TList & List<T>) | (TList & null) | (TList & undefined)), iteratee?: ListIterator<T, any>): TList, <T extends object>(collection: (T | null | undefined), iteratee?: ObjectIterator<T, any>): (T | null | undefined)}, isMap?(value?: any): value is Map<any, any>, assignInWith?: {<TObject, TSource>(object: TObject, source: TSource, customizer: AssignCustomizer): (TObject & TSource), <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: AssignCustomizer): (TObject & TSource1 & TSource2), <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): (TObject & TSource1 & TSource2 & TSource3), <TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: AssignCustomizer): (TObject & TSource1 & TSource2 & TSource3 & TSource4), <TObject>(object: TObject): TObject, <TResult>(object: any, ...otherArgs: any[]): TResult}, extend?: {<TObject, TSource>(object: TObject, source: TSource): (TObject & TSource), <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): (TObject & TSource1 & TSource2), <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): (TObject & TSource1 & TSource2 & TSource3), <TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): (TObject & TSource1 & TSource2 & TSource3 & TSource4), <TObject>(object: TObject): TObject, <TResult>(object: any, ...otherArgs: any[]): TResult}, noConflict?(): typeof _, at?: {<T>(object: (Dictionary<T> | NumericDictionary<T> | null | undefined), ...props: PropertyPath[]): T[], <T extends object>(object: (T | null | undefined), ...props: Many<keyof T>): Array<T[keyof T]>}, delay?(func: (...args: any[]) => any, wait: number, ...args: any[]): number, defaults?: {<TObject, TSource>(object: TObject, source: TSource): NonNullable<TSource & TObject>, <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): NonNullable<TSource2 & TSource1 & TObject>, <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): NonNullable<TSource3 & TSource2 & TSource1 & TObject>, <TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): NonNullable<TSource4 & TSource3 & TSource2 & TSource1 & TObject>, <TObject>(object: TObject): NonNullable<TObject>, (object: any, ...sources: any[]): any}, size?(collection: (object | string | null | undefined)): number, endsWith?(string?: string, target?: string, position?: number): boolean, difference?<T>(array: (List<T> | null | undefined), ...values: List<T>): T[], toNumber?(value: any): number, camelCase?(string?: string): string, toFinite?(value: any): number, upperFirst?(string?: string): string, isArrayBuffer?(value?: any): value is ArrayBuffer, propertyOf?<T extends {}>(object: T): (path: PropertyPath) => any, intersectionWith?: {<T1, T2>(array: (List<T1> | null | undefined), values: List<T2>, comparator: Comparator2<T1, T2>): T1[], <T1, T2, T3>(array: (List<T1> | null | undefined), values1: List<T2>, values2: List<T3>, comparator: Comparator2<T1, T2 | T3>): T1[], <T1, T2, T3, T4>(array: (List<T1> | null | undefined), values1: List<T2>, values2: List<T3>, ...values: List<T4> | Comparator2<T1, T2 | T3 | T4>[]): T1[], <T>(array?: (List<T> | null), ...values: List<T> | Comparator2<T, never>[]): T[]}, orderBy?: {<T>(collection: (List<T> | null | undefined), iteratees?: Many<ListIterator<T, NotVoid>>, orders?: Many<boolean | "asc" | "desc">): T[], <T>(collection: (List<T> | null | undefined), iteratees?: Many<ListIteratee<T>>, orders?: Many<boolean | "asc" | "desc">): T[], <T extends object>(collection: (T | null | undefined), iteratees?: Many<ObjectIterator<T, NotVoid>>, orders?: Many<boolean | "asc" | "desc">): Array<T[keyof T]>, <T extends object>(collection: (T | null | undefined), iteratees?: Many<ObjectIteratee<T>>, orders?: Many<boolean | "asc" | "desc">): Array<T[keyof T]>}, extendWith?: {<TObject, TSource>(object: TObject, source: TSource, customizer: AssignCustomizer): (TObject & TSource), <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: AssignCustomizer): (TObject & TSource1 & TSource2), <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): (TObject & TSource1 & TSource2 & TSource3), <TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: AssignCustomizer): (TObject & TSource1 & TSource2 & TSource3 & TSource4), <TObject>(object: TObject): TObject, <TResult>(object: any, ...otherArgs: any[]): TResult}, sum?(collection: (List<any> | null | undefined)): number, groupBy?: {<T>(collection: (List<T> | null | undefined), iteratee?: ValueIteratee<T>): Dictionary<T[]>, <T extends object>(collection: (T | null | undefined), iteratee?: ValueIteratee<T[keyof T]>): Dictionary<Array<T[keyof T]>>}, sampleSize?: {<T>(collection: (Dictionary<T> | NumericDictionary<T> | null | undefined), n?: number): T[], <T extends object>(collection: (T | null | undefined), n?: number): Array<T[keyof T]>}, isFinite?(value?: any): boolean, result?<TResult>(object: any, path: PropertyPath, defaultValue?: (((...args: any[]) => TResult) | TResult)): TResult, overArgs?(func: (...args: any[]) => any, ...transforms: Many<(...args: any[]) => any>): (...args: any[]) => any, flowRight?: {<A extends any[], R1, R2, R3, R4, R5, R6, R7>(f7: (a: R6) => R7, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R7, <A extends any[], R1, R2, R3, R4, R5, R6>(f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R6, <A extends any[], R1, R2, R3, R4, R5>(f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R5, <A extends any[], R1, R2, R3, R4>(f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R4, <A extends any[], R1, R2, R3>(f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R3, <A extends any[], R1, R2>(f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R2, (...func: Many<(...args: any[]) => any>): (...args: any[]) => any}, isError?(value: any): value is Error, min?<T>(collection: (List<T> | null | undefined)): (T | undefined), partition?: {<T, U extends T>(collection: (List<T> | null | undefined), callback: ValueIteratorTypeGuard<T, U>): [U[], Array<Exclude<T, U>>], <T>(collection: (List<T> | null | undefined), callback: ValueIteratee<T>): [T[], T[]], <T extends object>(collection: (T | null | undefined), callback: ValueIteratee<T[keyof T]>): [Array<T[keyof T]>, Array<T[keyof T]>]}, stubFalse?: {(): false, (): false}, isDate?(value?: any): value is Date, pullAllWith?: {<T>(array: T[], values?: List<T>, comparator?: Comparator<T>): T[], <T>(array: List<T>, values?: List<T>, comparator?: Comparator<T>): List<T>, <T1, T2>(array: T1[], values: List<T2>, comparator: Comparator2<T1, T2>): T1[], <T1, T2>(array: List<T1>, values: List<T2>, comparator: Comparator2<T1, T2>): List<T1>}, xor?<T>(...arrays: List<T> | null | undefined[]): T[], toPlainObject?(value?: any): any, omitBy?: {<T>(object: (Dictionary<T> | null | undefined), predicate?: ValueKeyIteratee<T>): Dictionary<T>, <T>(object: (NumericDictionary<T> | null | undefined), predicate?: ValueKeyIteratee<T>): NumericDictionary<T>, <T extends object>(object: (T | null | undefined), predicate: ValueKeyIteratee<T[keyof T]>): PartialObject<T>}, after?<TFunc extends (...args: any[]) => any>(n: number, func: TFunc): TFunc, escape?(string?: string): string, flip?<T extends (...args: any) => any>(func: T): T, uniqBy?<T>(array: (List<T> | null | undefined), iteratee: ValueIteratee<T>): T[], overSome?: {<T, Result1 extends T, Result2 extends T>(...predicates: [((arg: T) => arg is Result1), ((arg: T) => arg is Result2)]): (arg: T) => arg is Result1 | Result2, <T>(...predicates: Many<(...args: T[]) => boolean>): (...args: T[]) => boolean}, isWeakMap?(value?: any): value is WeakMap<object, any>, set?: {<T extends object>(object: T, path: PropertyPath, value: any): T, <TResult>(object: object, path: PropertyPath, value: any): TResult}, tail?<T>(array: (List<T> | null | undefined)): T[], keysIn?(object?: any): string[], words?: {(string?: string, pattern?: (string | RegExp)): string[], (string: string, index: (string | number), guard: object): string[]}, ary?(func: (...args: any[]) => any, n?: number): (...args: any[]) => any, sortedUniqBy?<T>(array: (List<T> | null | undefined), iteratee: ValueIteratee<T>): T[], union?<T>(...arrays: List<T> | null | undefined[]): T[], isEqualWith?(value: any, other: any, customizer?: IsEqualCustomizer): boolean, sample?: {<T>(collection: (Dictionary<T> | NumericDictionary<T> | null | undefined)): (T | undefined), <T extends object>(collection: (T | null | undefined)): (T[keyof T] | undefined)}, findLast?: {<T, S extends T>(collection: (List<T> | null | undefined), predicate: ListIteratorTypeGuard<T, S>, fromIndex?: number): (S | undefined), <T>(collection: (List<T> | null | undefined), predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): (T | undefined), <T extends object, S extends T[keyof T]>(collection: (T | null | undefined), predicate: ObjectIteratorTypeGuard<T, S>, fromIndex?: number): (S | undefined), <T extends object>(collection: (T | null | undefined), predicate?: ObjectIterateeCustom<T, boolean>, fromIndex?: number): (T[keyof T] | undefined)}, pull?: {<T>(array: T[], ...values: T[]): T[], <T>(array: List<T>, ...values: T[]): List<T>}, zipObjectDeep?(paths?: List<PropertyPath>, values?: List<any>): object, dropRightWhile?<T>(array: (List<T> | null | undefined), predicate?: ListIteratee<T>): T[], negate?<T extends any[]>(predicate: (...args: T) => boolean): (...args: T) => boolean, isNull?(value: any): value is null, toUpper?(string?: string): string, minBy?<T>(collection: (List<T> | null | undefined), iteratee?: ValueIteratee<T>): (T | undefined), toString?(value: any): string, curryRight?: CurryRight, flatMapDepth?: {<T>(collection: (Dictionary<ListOfRecursiveArraysOrValues<T> | T> | NumericDictionary<ListOfRecursiveArraysOrValues<T> | T> | null | undefined)): T[], <T, TResult>(collection: (List<T> | null | undefined), iteratee: ListIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>, depth?: number): TResult[], <T extends object, TResult>(collection: (T | null | undefined), iteratee: ObjectIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>, depth?: number): TResult[], (collection: (object | null | undefined), iteratee: string, depth?: number): any[], (collection: (object | null | undefined), iteratee: object, depth?: number): boolean[]}, wrap?<T, TArgs, TResult>(value: T, wrapper: (value: T, ...args: TArgs[]) => TResult): (...args: TArgs[]) => TResult, overEvery?: {<T, Result1 extends T, Result2 extends T>(...predicates: [((arg: T) => arg is Result1), ((arg: T) => arg is Result2)]): (arg: T) => arg is Result1 & Result2, <T>(...predicates: Many<(...args: T[]) => boolean>): (...args: T[]) => boolean}, conforms?<T>(source: ConformsPredicateObject<T>): (value: T) => boolean, differenceWith?: {<T1, T2>(array: (List<T1> | null | undefined), values: List<T2>, comparator: Comparator2<T1, T2>): T1[], <T1, T2, T3>(array: (List<T1> | null | undefined), values1: List<T2>, values2: List<T3>, comparator: Comparator2<T1, T2 | T3>): T1[], <T1, T2, T3, T4>(array: (List<T1> | null | undefined), values1: List<T2>, values2: List<T3>, ...values: List<T4> | Comparator2<T1, T2 | T3 | T4>[]): T1[], <T>(array: (List<T> | null | undefined), ...values: List<T>): T[]}, isEqual?(value: any, other: any): boolean, sumBy?<T>(collection: (List<T> | null | undefined), iteratee?: (((value: T) => number) | string)): number, isLength?(value?: any): boolean, isNaN?(value?: any): boolean, isNative?(value: any): value is (...args: any[]) => any, isInteger?(value?: any): boolean, pad?(string?: string, length?: number, chars?: string): string, intersection?<T>(...arrays: List<T> | null | undefined[]): T[], lowerCase?(string?: string): string, pullAt?: {<T>(array: T[], ...indexes: Many<number>): T[], <T>(array: List<T>, ...indexes: Many<number>): List<T>}, sortedUniq?<T>(array: (List<T> | null | undefined)): T[], has?<T>(object: T, path: PropertyPath): boolean, add?(augend: number, addend: number): number, padStart?(string?: string, length?: number, chars?: string): string, last?<T>(array: (List<T> | null | undefined)): (T | undefined), invert?(object: object): Dictionary<string>, kebabCase?(string?: string): string, mapKeys?: {<T>(object: (List<T> | null | undefined), iteratee?: ListIteratee<T>): Dictionary<T>, <T extends object>(object: (T | null | undefined), iteratee?: ObjectIteratee<T>): Dictionary<T[keyof T]>}, eq?(value: any, other: any): boolean, mixin?: {<TObject>(object: TObject, source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): TObject, <TResult>(source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): _.LoDashStatic}, flatMap?: {<T>(collection: (Dictionary<Many<T>> | NumericDictionary<Many<T>> | null | undefined)): T[], (collection: (object | null | undefined)): any[], <T, TResult>(collection: (List<T> | null | undefined), iteratee: ListIterator<T, Many<TResult>>): TResult[], <T extends object, TResult>(collection: (T | null | undefined), iteratee: ObjectIterator<T, Many<TResult>>): TResult[], (collection: (object | null | undefined), iteratee: string): any[], (collection: (object | null | undefined), iteratee: object): boolean[]}, take?<T>(array: (List<T> | null | undefined), n?: number): T[], sortedLastIndexOf?<T>(array: (List<T> | null | undefined), value: T): number, once?<T extends (...args: any) => any>(func: T): T, partialRight?: PartialRight, hasIn?<T>(object: T, path: PropertyPath): boolean, fromPairs?: {<T>(pairs: (List<[PropertyName, T]> | null | undefined)): Dictionary<T>, (pairs: (List<any[]> | null | undefined)): Dictionary<any>}, isObjectLike?(value?: any): boolean, uniqueId?(prefix?: string): string, zipWith?: {<T, TResult>(arrays: List<T>, iteratee: (value1: T) => TResult): TResult[], <T1, T2, TResult>(arrays1: List<T1>, arrays2: List<T2>, iteratee: (value1: T1, value2: T2) => TResult): TResult[], <T1, T2, T3, TResult>(arrays1: List<T1>, arrays2: List<T2>, arrays3: List<T3>, iteratee: (value1: T1, value2: T2, value3: T3) => TResult): TResult[], <T1, T2, T3, T4, TResult>(arrays1: List<T1>, arrays2: List<T2>, arrays3: List<T3>, arrays4: List<T4>, iteratee: (value1: T1, value2: T2, value3: T3, value4: T4) => TResult): TResult[], <T1, T2, T3, T4, T5, TResult>(arrays1: List<T1>, arrays2: List<T2>, arrays3: List<T3>, arrays4: List<T4>, arrays5: List<T5>, iteratee: (value1: T1, value2: T2, value3: T3, value4: T4, value5: T5) => TResult): TResult[], <T, TResult>(...iteratee: ((...group: T[]) => TResult) | List<T> | null | undefined[]): TResult[]}, drop?<T>(array: (List<T> | null | undefined), n?: number): T[], isArrayLikeObject?: {<T extends {__lodashAnyHack: any}>(value: T): boolean, (value: (((...args: any[]) => any) | FunctionBase | string | boolean | number | null | undefined)): value is never, (value: any): value is object & {length: number}}, some?: {<T>(collection: (List<T> | null | undefined), predicate?: ListIterateeCustom<T, boolean>): boolean, <T extends object>(collection: (T | null | undefined), predicate?: ObjectIterateeCustom<T, boolean>): boolean}, defer?(func: (...args: any[]) => any, ...args: any[]): number, findKey?<T>(object: (T | null | undefined), predicate?: ObjectIteratee<T>): (string | undefined), dropRight?<T>(array: (List<T> | null | undefined), n?: number): T[], isRegExp?(value?: any): value is RegExp, update?(object: object, path: PropertyPath, updater: (value: any) => any): any, isArrayLike?: {<T extends {__lodashAnyHack: any}>(t: T): boolean, (value: (((...args: any[]) => any) | null | undefined)): value is never, (value: any): value is {length: number}}, remove?<T>(array: List<T>, predicate?: ListIteratee<T>): T[], sortedIndexOf?<T>(array: (List<T> | null | undefined), value: T): number, random?: {(floating?: boolean): number, (max: number, floating?: boolean): number, (min: number, max: number, floating?: boolean): number, (min: number, index: (string | number), guard: object): number}, countBy?: {<T>(collection: (List<T> | null | undefined), iteratee?: ValueIteratee<T>): Dictionary<number>, <T extends object>(collection: (T | null | undefined), iteratee?: ValueIteratee<T[keyof T]>): Dictionary<number>}, isBoolean?(value?: any): value is boolean, zipObject?: {<T>(props: List<PropertyName>, values: List<T>): Dictionary<T>, (props?: List<PropertyName>): Dictionary<undefined>}, now?(): number, differenceBy?: {<T1, T2>(array: (List<T1> | null | undefined), values: List<T2>, iteratee: ValueIteratee<T1 | T2>): T1[], <T1, T2, T3>(array: (List<T1> | null | undefined), values1: List<T2>, values2: List<T3>, iteratee: ValueIteratee<T1 | T2 | T3>): T1[], <T1, T2, T3, T4>(array: (List<T1> | null | undefined), values1: List<T2>, values2: List<T3>, values3: List<T4>, iteratee: ValueIteratee<T1 | T2 | T3 | T4>): T1[], <T1, T2, T3, T4, T5>(array: (List<T1> | null | undefined), values1: List<T2>, values2: List<T3>, values3: List<T4>, values4: List<T5>, iteratee: ValueIteratee<T1 | T2 | T3 | T4 | T5>): T1[], <T1, T2, T3, T4, T5, T6>(array: (List<T1> | null | undefined), values1: List<T2>, values2: List<T3>, values3: List<T4>, values4: List<T5>, values5: List<T6>, iteratee: ValueIteratee<T1 | T2 | T3 | T4 | T5 | T6>): T1[], <T1, T2, T3, T4, T5, T6, T7>(array: (List<T1> | null | undefined), values1: List<T2>, values2: List<T3>, values3: List<T4>, values4: List<T5>, values5: List<T6>, ...values: List<T7> | ValueIteratee<T1 | T2 | T3 | T4 | T5 | T6 | T7>[]): T1[], <T>(array: (List<T> | null | undefined), ...values: List<T>): T[]}, isString?(value?: any): value is string, divide?(dividend: number, divisor: number): number, multiply?(multiplier: number, multiplicand: number): number, sortedIndex?: {<T>(array: (List<T> | null | undefined), value: T): number, <T>(array: (List<T> | null | undefined), value: T): number}, xorBy?: {<T>(arrays: (List<T> | null | undefined), iteratee?: ValueIteratee<T>): T[], <T>(arrays: (List<T> | null | undefined), arrays2: (List<T> | null | undefined), iteratee?: ValueIteratee<T>): T[], <T>(arrays: (List<T> | null | undefined), arrays2: (List<T> | null | undefined), arrays3: (List<T> | null | undefined), ...iteratee: ValueIteratee<T> | List<T> | null | undefined[]): T[]}, every?: {<T>(collection: (List<T> | null | undefined), predicate?: ListIterateeCustom<T, boolean>): boolean, <T extends object>(collection: (T | null | undefined), predicate?: ObjectIterateeCustom<T, boolean>): boolean}, over?<TResult>(...iteratees: Many<(...args: any[]) => TResult>): (...args: any[]) => TResult[], cloneDeepWith?: {<T>(value: T, customizer: CloneDeepWithCustomizer<T>): any, <T>(value: T): T}, isEmpty?: {<T extends {__trapAny: any}>(value?: T): boolean, (value: string): value is "", (value: (Map<any, any> | Set<any> | List<any> | null | undefined)): boolean, (value: object): boolean, <T extends object>(value: (T | null | undefined)): value is EmptyObjectOf<T> | null | undefined, (value?: any): boolean}, isSafeInteger?(value: any): boolean, defaultTo?: {<T>(value: (T | null | undefined), defaultValue: T): T, <T, TDefault>(value: (T | null | undefined), defaultValue: TDefault): (T | TDefault)}, gt?(value: any, other: any): boolean, findIndex?<T>(array: (List<T> | null | undefined), predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): number, parseInt?(string: string, radix?: number): number, lastIndexOf?<T>(array: (List<T> | null | undefined), value: T, fromIndex?: (true | number)): number, stubTrue?: {(): true, (): true}, findLastKey?<T>(object: (T | null | undefined), predicate?: ObjectIteratee<T>): (string | undefined), isMatchWith?(object: object, source: object, customizer: isMatchWithCustomizer): boolean, maxBy?<T>(collection: (List<T> | null | undefined), iteratee?: ValueIteratee<T>): (T | undefined), clone?<T>(value: T): T, assign?: {<TObject, TSource>(object: TObject, source: TSource): (TObject & TSource), <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): (TObject & TSource1 & TSource2), <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): (TObject & TSource1 & TSource2 & TSource3), <TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): (TObject & TSource1 & TSource2 & TSource3 & TSource4), <TObject>(object: TObject): TObject, (object: any, ...otherArgs: any[]): any}, keyBy?: {<T>(collection: (List<T> | null | undefined), iteratee?: ValueIterateeCustom<T, PropertyName>): Dictionary<T>, <T extends object>(collection: (T | null | undefined), iteratee?: ValueIterateeCustom<T[keyof T], PropertyName>): Dictionary<T[keyof T]>}, invoke?(object: any, path: PropertyPath, ...args: any[]): any, cond?: {<R>(pairs: Array<CondPairNullary<R>>): () => R, <T, R>(pairs: Array<CondPairUnary<T, R>>): (Target: T) => R}, attempt?<TResult>(func: (...args: any[]) => TResult, ...args: any[]): (Error | TResult), methodOf?(object: object, ...args: any[]): (path: PropertyPath) => any, truncate?(string?: string, options?: TruncateOptions): string, slice?<T>(array: (List<T> | null | undefined), start?: number, end?: number): T[], templateSettings?: TemplateSettings, toArray?: {<T>(value: (Dictionary<T> | NumericDictionary<T> | null | undefined)): T[], <T>(value: T): Array<T[keyof T]>, (): any[]}, property?<TObj, TResult>(path: PropertyPath): (obj: TObj) => TResult, takeRightWhile?<T>(array: (List<T> | null | undefined), predicate?: ListIteratee<T>): T[], gte?(value: any, other: any): boolean, isWeakSet?(value?: any): value is WeakSet<object>, isUndefined?(value: any): value is undefined, join?(array: (List<any> | null | undefined), separator?: string): string, runInContext?(context?: object): _.LoDashStatic, clamp?: {(number: number, lower: number, upper: number): number, (number: number, upper: number): number}, toSafeInteger?(value: any): number, trimStart?: {(string?: string, chars?: string): string, (string: string, index: (string | number), guard: object): string}, flow?: {<A extends any[], R1, R2, R3, R4, R5, R6, R7>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): (...args: A) => R7, <A extends any[], R1, R2, R3, R4, R5, R6, R7>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7, ...func: Many<(a: any) => any>): (...args: A) => any, <A extends any[], R1, R2, R3, R4, R5, R6>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6): (...args: A) => R6, <A extends any[], R1, R2, R3, R4, R5>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5): (...args: A) => R5, <A extends any[], R1, R2, R3, R4>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4): (...args: A) => R4, <A extends any[], R1, R2, R3>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3): (...args: A) => R3, <A extends any[], R1, R2>(f1: (...args: A) => R1, f2: (a: R1) => R2): (...args: A) => R2, (...func: Many<(...args: any[]) => any>): (...args: any[]) => any}, zip?: {<T1, T2>(arrays1: List<T1>, arrays2: List<T2>): Array<[(T1 | undefined), (T2 | undefined)]>, <T1, T2, T3>(arrays1: List<T1>, arrays2: List<T2>, arrays3: List<T3>): Array<[(T1 | undefined), (T2 | undefined), (T3 | undefined)]>, <T1, T2, T3, T4>(arrays1: List<T1>, arrays2: List<T2>, arrays3: List<T3>, arrays4: List<T4>): Array<[(T1 | undefined), (T2 | undefined), (T3 | undefined), (T4 | undefined)]>, <T1, T2, T3, T4, T5>(arrays1: List<T1>, arrays2: List<T2>, arrays3: List<T3>, arrays4: List<T4>, arrays5: List<T5>): Array<[(T1 | undefined), (T2 | undefined), (T3 | undefined), (T4 | undefined), (T5 | undefined)]>, <T>(...arrays: List<T> | null | undefined[]): Array<Array<T | undefined>>}, reduce?: {<T, TResult>(collection: (T[] | null | undefined), callback: MemoListIterator<T, TResult, T[]>, accumulator: TResult): TResult, <T, TResult>(collection: (List<T> | null | undefined), callback: MemoListIterator<T, TResult, List<T>>, accumulator: TResult): TResult, <T extends object, TResult>(collection: (T | null | undefined), callback: MemoObjectIterator<T[keyof T], TResult, T>, accumulator: TResult): TResult, <T>(collection: (T[] | null | undefined), callback: MemoListIterator<T, T, T[]>): (T | undefined), <T>(collection: (List<T> | null | undefined), callback: MemoListIterator<T, T, List<T>>): (T | undefined), <T extends object>(collection: (T | null | undefined), callback: MemoObjectIterator<T[keyof T], T[keyof T], T>): (T[keyof T] | undefined)}, method?(path: PropertyPath, ...args: any[]): (object: any) => any, isSet?(value?: any): value is Set<any>, sortedLastIndex?<T>(array: (List<T> | null | undefined), value: T): number, ceil?(n: number, precision?: number): number, matches?: {<T>(source: T): (value: any) => boolean, <T, V>(source: T): (value: V) => boolean}, curry?: Curry, sortedLastIndexBy?<T>(array: (List<T> | null | undefined), value: T, iteratee: ValueIteratee<T>): number, rearg?(func: (...args: any[]) => any, ...indexes: Many<number>): (...args: any[]) => any, isArray?: {(value?: any): value is any[], <T>(value?: any): value is any[]}, conformsTo?<T>(object: T, source: ConformsPredicateObject<T>): boolean, partial?: Partial, template?(string?: string, options?: TemplateOptions): TemplateExecutor, meanBy?<T>(collection: (List<T> | null | undefined), iteratee?: ValueIteratee<T>): number, throttle?<T extends (...args: any) => any>(func: T, wait?: number, options?: ThrottleSettings): DebouncedFunc<T>, forOwnRight?: {<T>(object: T, iteratee?: ObjectIterator<T, any>): T, <T>(object: (T | null | undefined), iteratee?: ObjectIterator<T, any>): (T | null | undefined)}, entriesIn?: {<T>(object?: (Dictionary<T> | NumericDictionary<T>)): Array<[string, T]>, (object?: object): Array<[string, any]>}, cloneDeep?<T>(value: T): T, takeRight?<T>(array: (List<T> | null | undefined), n?: number): T[], stubArray?(): any[], range?: {(start: number, end?: number, step?: number): number[], (end: number, index: (string | number), guard: object): number[]}, unzip?<T>(array: (T[][] | List<List<T>> | null | undefined)): T[][], pickBy?: {<T, S extends T>(object: (Dictionary<T> | null | undefined), predicate: ValueKeyIterateeTypeGuard<T, S>): Dictionary<S>, <T, S extends T>(object: (NumericDictionary<T> | null | undefined), predicate: ValueKeyIterateeTypeGuard<T, S>): NumericDictionary<S>, <T>(object: (Dictionary<T> | null | undefined), predicate?: ValueKeyIteratee<T>): Dictionary<T>, <T>(object: (NumericDictionary<T> | null | undefined), predicate?: ValueKeyIteratee<T>): NumericDictionary<T>, <T extends object>(object: (T | null | undefined), predicate?: ValueKeyIteratee<T[keyof T]>): PartialObject<T>}, forEachRight?: {<T>(collection: T[], iteratee?: ArrayIterator<T, any>): T[], (collection: string, iteratee?: StringIterator<any>): string, <T>(collection: List<T>, iteratee?: ListIterator<T, any>): List<T>, <T extends object>(collection: T, iteratee?: ObjectIterator<T, any>): T, <T, TArray extends T[] | null | undefined>(collection: ((TArray & T[]) | (TArray & null) | (TArray & undefined)), iteratee?: ArrayIterator<T, any>): TArray, <TString extends string | null | undefined>(collection: TString, iteratee?: StringIterator<any>): TString, <T, TList extends List<T> | null | undefined>(collection: ((TList & List<T>) | (TList & null) | (TList & undefined)), iteratee?: ListIterator<T, any>): TList, <T extends object>(collection: (T | null | undefined), iteratee?: ObjectIterator<T, any>): (T | null | undefined)}, memoize?: {<T extends (...args: any) => any>(func: T, resolver?: (...args: Parameters<T>) => any): (T & MemoizedFunction), Cache: MapCacheConstructor}, sortedIndexBy?<T>(array: (List<T> | null | undefined), value: T, iteratee?: ValueIteratee<T>): number, toPairs?: {<T>(object?: (Dictionary<T> | NumericDictionary<T>)): Array<[string, T]>, (object?: object): Array<[string, any]>}, noop?(...args: any[]): void, identity?: {<T>(value: T): T, (): undefined}, get?: {<TObject extends object, TKey extends keyof TObject>(object: TObject, path: ([TKey] | TKey)): TObject[TKey], <TObject extends object, TKey extends keyof TObject>(object: (TObject | null | undefined), path: ([TKey] | TKey)): (TObject[TKey] | undefined), <TObject extends object, TKey extends keyof TObject, TDefault>(object: (TObject | null | undefined), path: ([TKey] | TKey), defaultValue: TDefault): (Exclude<TObject[TKey], undefined> | TDefault), <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(object: TObject, path: [TKey1, TKey2]): TObject[TKey1][TKey2], <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(object: (TObject | null | undefined), path: [TKey1, TKey2]): (TObject[TKey1][TKey2] | undefined), <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TDefault>(object: (TObject | null | undefined), path: [TKey1, TKey2], defaultValue: TDefault): (Exclude<TObject[TKey1][TKey2], undefined> | TDefault), <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(object: TObject, path: [TKey1, TKey2, TKey3]): TObject[TKey1][TKey2][TKey3], <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(object: (TObject | null | undefined), path: [TKey1, TKey2, TKey3]): (TObject[TKey1][TKey2][TKey3] | undefined), <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TDefault>(object: (TObject | null | undefined), path: [TKey1, TKey2, TKey3], defaultValue: TDefault): (Exclude<TObject[TKey1][TKey2][TKey3], undefined> | TDefault), <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(object: TObject, path: [TKey1, TKey2, TKey3, TKey4]): TObject[TKey1][TKey2][TKey3][TKey4], <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(object: (TObject | null | undefined), path: [TKey1, TKey2, TKey3, TKey4]): (TObject[TKey1][TKey2][TKey3][TKey4] | undefined), <TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3], TDefault>(object: (TObject | null | undefined), path: [TKey1, TKey2, TKey3, TKey4], defaultValue: TDefault): (Exclude<TObject[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault), <T>(object: NumericDictionary<T>, path: number): T, <T>(object: (NumericDictionary<T> | null | undefined), path: number): (T | undefined), <T, TDefault>(object: (NumericDictionary<T> | null | undefined), path: number, defaultValue: TDefault): (T | TDefault), <TDefault>(object: (null | undefined), path: PropertyPath, defaultValue: TDefault): TDefault, (object: (null | undefined), path: PropertyPath): undefined, <TObject, TPath extends string>(data: TObject, path: TPath): string extends TPath ? any : GetFieldType<TObject, TPath>, <TObject, TPath extends string, TDefault=GetFieldType<TObject, TPath>>(data: TObject, path: TPath, defaultValue: TDefault): (Exclude<GetFieldType<TObject, TPath>, null | undefined> | TDefault), (object: any, path: PropertyPath, defaultValue?: any): any}, iteratee?: {<TFunction extends (...args: any[]) => any>(func: TFunction): TFunction, (func: (symbol | number | string | object)): (...args: any[]) => any}, map?: {<T, TResult>(collection: (T[] | null | undefined), iteratee: ArrayIterator<T, TResult>): TResult[], <T, TResult>(collection: (List<T> | null | undefined), iteratee: ListIterator<T, TResult>): TResult[], <T>(collection: (Dictionary<T> | NumericDictionary<T> | null | undefined)): T[], <T extends object, TResult>(collection: (T | null | undefined), iteratee: ObjectIterator<T, TResult>): TResult[], <T, K extends keyof T>(collection: (Dictionary<T> | NumericDictionary<T> | null | undefined), iteratee: K): Array<T[K]>, <T>(collection: (Dictionary<T> | NumericDictionary<T> | null | undefined), iteratee?: string): any[], <T>(collection: (Dictionary<T> | NumericDictionary<T> | null | undefined), iteratee?: object): boolean[]}, chain?: {<TrapAny extends {__lodashAnyHack: any}>(value: TrapAny): (CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain), <T extends null | undefined>(value: T): PrimitiveChain<T>, (value: string): StringChain, (value: (string | null | undefined)): StringNullableChain, <T extends (...args: any[]) => any>(value: T): FunctionChain<T>, <T=any>(value: (List<T> | null | undefined)): CollectionChain<T>, <T extends object>(value: (T | null | undefined)): ObjectChain<T>, <T>(value: T): PrimitiveChain<T>}, findLastIndex?<T>(array: (List<T> | null | undefined), predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): number, nth?<T>(array: (List<T> | null | undefined), n?: number): (T | undefined), initial?<T>(array: (List<T> | null | undefined)): T[], max?<T>(collection: (List<T> | null | undefined)): (T | undefined), toLower?(string?: string): string, dropWhile?<T>(array: (List<T> | null | undefined), predicate?: ListIteratee<T>): T[], reverse?<TList extends List<any>>(array: TList): TList, bindKey?: FunctionBindKey, unionBy?: {<T>(arrays: (List<T> | null | undefined), iteratee?: ValueIteratee<T>): T[], <T>(arrays1: (List<T> | null | undefined), arrays2: (List<T> | null | undefined), iteratee?: ValueIteratee<T>): T[], <T>(arrays1: (List<T> | null | undefined), arrays2: (List<T> | null | undefined), arrays3: (List<T> | null | undefined), iteratee?: ValueIteratee<T>): T[], <T>(arrays1: (List<T> | null | undefined), arrays2: (List<T> | null | undefined), arrays3: (List<T> | null | undefined), arrays4: (List<T> | null | undefined), iteratee?: ValueIteratee<T>): T[], <T>(arrays1: (List<T> | null | undefined), arrays2: (List<T> | null | undefined), arrays3: (List<T> | null | undefined), arrays4: (List<T> | null | undefined), arrays5: (List<T> | null | undefined), ...iteratee: ValueIteratee<T> | List<T> | null | undefined[]): T[]}, filter?: {(collection: (string | null | undefined), predicate?: StringIterator<boolean>): string[], <T, S extends T>(collection: (List<T> | null | undefined), predicate: ListIteratorTypeGuard<T, S>): S[], <T>(collection: (List<T> | null | undefined), predicate?: ListIterateeCustom<T, boolean>): T[], <T extends object, S extends T[keyof T]>(collection: (T | null | undefined), predicate: ObjectIteratorTypeGuard<T, S>): S[], <T extends object>(collection: (T | null | undefined), predicate?: ObjectIterateeCustom<T, boolean>): Array<T[keyof T]>}, updateWith?: {<T extends object>(object: T, path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<T>): T, <T extends object, TResult>(object: T, path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<T>): TResult}, cloneWith?: {<T, TResult extends object | string | number | boolean | null>(value: T, customizer: CloneWithCustomizer<T, TResult>): TResult, <T, TResult>(value: T, customizer: CloneWithCustomizer<T, TResult | undefined>): (TResult | T), <T>(value: T): T}, assignWith?: {<TObject, TSource>(object: TObject, source: TSource, customizer: AssignCustomizer): (TObject & TSource), <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: AssignCustomizer): (TObject & TSource1 & TSource2), <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): (TObject & TSource1 & TSource2 & TSource3), <TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: AssignCustomizer): (TObject & TSource1 & TSource2 & TSource3 & TSource4), <TObject>(object: TObject): TObject, <TResult>(object: any, ...otherArgs: any[]): TResult}, toPath?(value: any): string[], VERSION?: string, isNil?(value: any): value is null | undefined, shuffle?: {<T>(collection: (List<T> | null | undefined)): T[], <T extends object>(collection: (T | null | undefined)): Array<T[keyof T]>}, first?: <T>(array: (List<T> | null | undefined)) => (T | undefined), assignIn?: {<TObject, TSource>(object: TObject, source: TSource): (TObject & TSource), <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): (TObject & TSource1 & TSource2), <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): (TObject & TSource1 & TSource2 & TSource3), <TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): (TObject & TSource1 & TSource2 & TSource3 & TSource4), <TObject>(object: TObject): TObject, <TResult>(object: any, ...otherArgs: any[]): TResult}, thru?<T, TResult>(value: T, interceptor: (value: T) => TResult): TResult, uniqWith?<T>(array: (List<T> | null | undefined), comparator?: Comparator<T>): T[], constant?<T>(value: T): () => T, compact?<T>(array: (List<Falsey | T> | null | undefined)): T[], isPlainObject?(value?: any): boolean, flattenDepth?<T>(array: (ListOfRecursiveArraysOrValues<T> | null | undefined), depth?: number): T[], before?<TFunc extends (...args: any[]) => any>(n: number, func: TFunc): TFunc, lt?(value: any, other: any): boolean, replace?: {(string: string, pattern: (RegExp | string), replacement: (ReplaceFunction | string)): string, (pattern: (RegExp | string), replacement: (ReplaceFunction | string)): string}, unary?<T, TResult>(func: (arg1: T, ...args: any[]) => TResult): (arg1: T) => TResult, trimEnd?: {(string?: string, chars?: string): string, (string: string, index: (string | number), guard: object): string}, unset?(object: any, path: PropertyPath): boolean, unzipWith?: {<T, TResult>(array: (List<List<T>> | null | undefined), iteratee: (...values: T[]) => TResult): TResult[], <T>(array: (List<List<T>> | null | undefined)): T[][]}, flatMapDeep?: {<T>(collection: (Dictionary<ListOfRecursiveArraysOrValues<T> | T> | NumericDictionary<ListOfRecursiveArraysOrValues<T> | T> | null | undefined)): T[], <T, TResult>(collection: (List<T> | null | undefined), iteratee: ListIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>): TResult[], <T extends object, TResult>(collection: (T | null | undefined), iteratee: ObjectIterator<T, ListOfRecursiveArraysOrValues<TResult> | TResult>): TResult[], (collection: (object | null | undefined), iteratee: string): any[], (collection: (object | null | undefined), iteratee: object): boolean[]}, flatten?<T>(array: (List<Many<T>> | null | undefined)): T[], snakeCase?(string?: string): string, lowerFirst?(string?: string): string, split?: {(string: (string | null | undefined), separator?: (RegExp | string), limit?: number): string[], (string: (string | null | undefined), index: (string | number), guard: object): string[]}, isNumber?(value?: any): value is number, find?: {<T, S extends T>(collection: (List<T> | null | undefined), predicate: ListIteratorTypeGuard<T, S>, fromIndex?: number): (S | undefined), <T>(collection: (List<T> | null | undefined), predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): (T | undefined), <T extends object, S extends T[keyof T]>(collection: (T | null | undefined), predicate: ObjectIteratorTypeGuard<T, S>, fromIndex?: number): (S | undefined), <T extends object>(collection: (T | null | undefined), predicate?: ObjectIterateeCustom<T, boolean>, fromIndex?: number): (T[keyof T] | undefined)}, pullAll?: {<T>(array: T[], values?: List<T>): T[], <T>(array: List<T>, values?: List<T>): List<T>}, create?<T extends object, U extends object>(prototype: T, properties?: U): (T & U), indexOf?<T>(array: (List<T> | null | undefined), value: T, fromIndex?: number): number, pullAllBy?: {<T>(array: T[], values?: List<T>, iteratee?: ValueIteratee<T>): T[], <T>(array: List<T>, values?: List<T>, iteratee?: ValueIteratee<T>): List<T>, <T1, T2>(array: T1[], values: List<T2>, iteratee: ValueIteratee<T1 | T2>): T1[], <T1, T2>(array: List<T1>, values: List<T2>, iteratee: ValueIteratee<T1 | T2>): List<T1>}, forOwn?: {<T>(object: T, iteratee?: ObjectIterator<T, any>): T, <T>(object: (T | null | undefined), iteratee?: ObjectIterator<T, any>): (T | null | undefined)}, tap?<T>(value: T, interceptor: (value: T) => void): T, invertBy?: {<T>(object: (Dictionary<T> | NumericDictionary<T> | null | undefined), interatee?: ValueIteratee<T>): Dictionary<string[]>, <T extends object>(object: (T | null | undefined), interatee?: ValueIteratee<T[keyof T]>): Dictionary<string[]>}, isArguments?(value?: any): value is IArguments, bindAll?<T>(object: T, ...methodNames: Many<string>): T, includes?<T>(collection: (Dictionary<T> | NumericDictionary<T> | null | undefined), target: T, fromIndex?: number): boolean, invokeMap?: {(collection: (object | null | undefined), methodName: string, ...args: any[]): any[], <TResult>(collection: (object | null | undefined), method: (...args: any[]) => TResult, ...args: any[]): TResult[]}, castArray?<T>(value?: Many<T>): T[], forInRight?: {<T>(object: T, iteratee?: ObjectIterator<T, any>): T, <T>(object: (T | null | undefined), iteratee?: ObjectIterator<T, any>): (T | null | undefined)}, fill?: {<T>(array: (any[] | null | undefined), value: T): T[], <T>(array: (List<any> | null | undefined), value: T): List<T>, <T, U>(array: (U[] | null | undefined), value: T, start?: number, end?: number): Array<T | U>, <T, U>(array: (List<U> | null | undefined), value: T, start?: number, end?: number): List<T | U>}, isMatch?(object: object, source: object): boolean, entries?: {<T>(object?: (Dictionary<T> | NumericDictionary<T>)): Array<[string, T]>, (object?: object): Array<[string, any]>}, deburr?(string?: string): string, upperCase?(string?: string): string, uniq?<T>(array: (List<T> | null | undefined)): T[], omit?: {<T extends object, K extends PropertyName[]>(object: (T | null | undefined), ...paths: K): Pick<T, Exclude<keyof T, K[number]>>, <T extends object, K extends keyof T>(object: (T | null | undefined), ...paths: Many<K>): Omit<T, K>, <T extends object>(object: (T | null | undefined), ...paths: Many<PropertyName>): PartialObject<T>}, startCase?(string?: string): string, keys?(object?: any): string[], values?: {<T>(object: (Dictionary<T> | NumericDictionary<T> | List<T> | null | undefined)): T[], <T extends object>(object: (T | null | undefined)): Array<T[keyof T]>, (object: any): any[]}, chunk?<T>(array: (List<T> | null | undefined), size?: number): T[][], inRange?(n: number, start: number, end?: number): boolean, rangeRight?: {(start: number, end?: number, step?: number): number[], (end: number, index: (string | number), guard: object): number[]}, head?<T>(array: (List<T> | null | undefined)): (T | undefined), toInteger?(value: any): number, transform?: {<T, TResult>(object: ReadonlyArray<T>, iteratee: MemoVoidArrayIterator<T, TResult>, accumulator?: TResult): TResult, <T, TResult>(object: Dictionary<T>, iteratee: MemoVoidDictionaryIterator<T, string, TResult>, accumulator?: TResult): TResult, <T extends object, TResult>(object: T, iteratee: MemoVoidDictionaryIterator<T[keyof T], keyof T, TResult>, accumulator?: TResult): TResult, (object: any[]): any[], (object: object): Dictionary<any>}, times?: {<TResult>(n: number, iteratee: (num: number) => TResult): TResult[], (n: number): number[]}, reject?: {(collection: (string | null | undefined), predicate?: StringIterator<boolean>): string[], <T>(collection: (List<T> | null | undefined), predicate?: ListIterateeCustom<T, boolean>): T[], <T extends object>(collection: (T | null | undefined), predicate?: ObjectIterateeCustom<T, boolean>): Array<T[keyof T]>}, repeat?(string?: string, n?: number): string, functionsIn?<T extends {}>(object: any): string[], reduceRight?: {<T, TResult>(collection: (T[] | null | undefined), callback: MemoListIterator<T, TResult, T[]>, accumulator: TResult): TResult, <T, TResult>(collection: (List<T> | null | undefined), callback: MemoListIterator<T, TResult, List<T>>, accumulator: TResult): TResult, <T extends object, TResult>(collection: (T | null | undefined), callback: MemoObjectIterator<T[keyof T], TResult, T>, accumulator: TResult): TResult, <T>(collection: (T[] | null | undefined), callback: MemoListIterator<T, T, T[]>): (T | undefined), <T>(collection: (List<T> | null | undefined), callback: MemoListIterator<T, T, List<T>>): (T | undefined), <T extends object>(collection: (T | null | undefined), callback: MemoObjectIterator<T[keyof T], T[keyof T], T>): (T[keyof T] | undefined)}, lte?(value: any, other: any): boolean, nthArg?(n?: number): (...args: any[]) => any, floor?(n: number, precision?: number): number, rest?(func: (...args: any[]) => any, start?: number): (...args: any[]) => any, mergeWith?: {<TObject, TSource>(object: TObject, source: TSource, customizer: MergeWithCustomizer): (TObject & TSource), <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: MergeWithCustomizer): (TObject & TSource1 & TSource2), <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, customizer: MergeWithCustomizer): (TObject & TSource1 & TSource2 & TSource3), <TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: MergeWithCustomizer): (TObject & TSource1 & TSource2 & TSource3 & TSource4), (object: any, ...otherArgs: any[]): any}, escapeRegExp?(string?: string): string, forEach?: {<T>(collection: T[], iteratee?: ArrayIterator<T, any>): T[], (collection: string, iteratee?: StringIterator<any>): string, <T>(collection: List<T>, iteratee?: ListIterator<T, any>): List<T>, <T extends object>(collection: T, iteratee?: ObjectIterator<T, any>): T, <T, TArray extends T[] | null | undefined>(collection: ((TArray & T[]) | (TArray & null) | (TArray & undefined)), iteratee?: ArrayIterator<T, any>): TArray, <TString extends string | null | undefined>(collection: TString, iteratee?: StringIterator<any>): TString, <T, TList extends List<T> | null | undefined>(collection: ((TList & List<T>) | (TList & null) | (TList & undefined)), iteratee?: ListIterator<T, any>): TList, <T extends object>(collection: (T | null | undefined), iteratee?: ObjectIterator<T, any>): (T | null | undefined)}, mapValues?: {<TResult>(obj: (string | null | undefined), callback: StringIterator<TResult>): NumericDictionary<TResult>, <T extends object, TResult>(obj: (T | null | undefined), callback: ObjectIterator<T, TResult>): {[P in keyof T]: TResult}, <T>(obj: (Dictionary<T> | NumericDictionary<T> | null | undefined), iteratee: object): Dictionary<boolean>, <T extends object>(obj: (T | null | undefined), iteratee: object): {[P in keyof T]: boolean}, <T, TKey extends keyof T>(obj: (Dictionary<T> | NumericDictionary<T> | null | undefined), iteratee: TKey): Dictionary<T[TKey]>, <T>(obj: (Dictionary<T> | NumericDictionary<T> | null | undefined), iteratee: string): Dictionary<any>, <T extends object>(obj: (T | null | undefined), iteratee: string): {[P in keyof T]: any}, (obj: (string | null | undefined)): NumericDictionary<string>, <T>(obj: (Dictionary<T> | NumericDictionary<T> | null | undefined)): Dictionary<T>, <T extends object>(obj: T): T, <T extends object>(obj: (T | null | undefined)): PartialObject<T>}, matchesProperty?: {<T>(path: PropertyPath, srcValue: T): (value: any) => boolean, <T, V>(path: PropertyPath, srcValue: T): (value: V) => boolean}, unescape?(string?: string): string, padEnd?(string?: string, length?: number, chars?: string): string, spread?<TResult>(func: (...args: any[]) => TResult, start?: number): (...args: any[]) => TResult, round?(n: number, precision?: number): number, mean?(collection: (List<any> | null | undefined)): number, toPairsIn?: {<T>(object?: (Dictionary<T> | NumericDictionary<T>)): Array<[string, T]>, (object?: object): Array<[string, any]>}, flattenDeep?<T>(array: (ListOfRecursiveArraysOrValues<T> | null | undefined)): Array<Flat<T>>, stubObject?(): any, intersectionBy?: {<T1, T2>(array: (List<T1> | null), values: List<T2>, iteratee: ValueIteratee<T1 | T2>): T1[], <T1, T2, T3>(array: (List<T1> | null), values1: List<T2>, values2: List<T3>, iteratee: ValueIteratee<T1 | T2 | T3>): T1[], <T1, T2, T3, T4>(array: (List<T1> | null | undefined), values1: List<T2>, values2: List<T3>, ...values: List<T4> | ValueIteratee<T1 | T2 | T3 | T4>[]): T1[], <T>(array?: (List<T> | null), ...values: List<T>): T[], <T>(...values: List<T> | ValueIteratee<T>[]): T[]}, startsWith?(string?: string, target?: string, position?: number): boolean}}
 */
let $ = { ...lodash };
$.isStringArray = (value) => {
  try {
    return $.isArray(JSON.parse(value));
  } catch (e) {
    return false;
  }
};
/**
 *
 * @param value
 * @return {[]}
 * @constructor
 */
$.JSToArr = (value) => {
  return JSON.parse(value);
};

/**
 *
 * @param value
 * @return {string}
 * @constructor
 */
$.ObjToJS = (value) => {
  return JSON.stringify(value);
};

/**
 *
 * @param value
 * @return {Object}
 */
$.JSToObj = (value) => {
  return JSON.parse(value);
};
/**
 *
 * @param value {string}
 * @param condition {string}
 * @return {[]}
 */
$.split = (value, condition = "") => {
  return value.split(condition);
};

/**
 *
 * @param data {any}
 * @param _format {{this._format}}

 */
$.format = (data, _format) => {
  switch (typeof _format) {
    case "string":
      if (typeof data === "object") {
        return JSON.stringify(data);
      }
      return `${data}`;
    case "number":
      if (typeof data === "number") return data;
      if (typeof data === "string") return Number(data);
      return _format;
    case "boolean":
      if (typeof data === "boolean") return data;
      return _format;
    case "function":
      if (_format.toString().search("class") !== -1) {
        if (data instanceof _format) return data;
        return null;
      } else if (typeof data === "function") {
        return data;
      } else return function () {};
    case "object":
      if (!Array.isArray(_format)) {
        if (
          typeof data !== "object" ||
          data === undefined ||
          Array.isArray(data)
        )
          data = {};
        if (typeof data === "object" && Object.keys(_format).length === 0) {
          return data;
        } else if (
          typeof data === "object" &&
          Object.keys(_format).length > 0
        ) {
          for (let key of Object.keys(_format)) {
            if (
              data[key] === undefined &&
              typeof _format[key] !== "object" &&
              !Array.isArray(_format[key])
            ) {
              data[key] = _format[key];
            } else data[key] = this.format(data[key], _format[key]);
          }
        }

        return data;
      } else if (Array.isArray(_format)) {
        if (!Array.isArray(data)) data = [];
        if (Array.isArray(data) && _format.length === 0) return data;
        if (Array.isArray(data)) {
          return data.map((value) => {
            return this.format(value, _format[0]);
          });
        }
      }
      break;
    default:
      throw new Error("phuong thuc chua ho tro");
  }
};
$.qlk = (str) => {
  return `%${str}%`;
};
$.makeId = (length) => {
  let result = "";
  const characters = "abcdefghijklmnopqrstuvwxyz0123456789";
  const charactersLength = characters.length;
  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
};
$.timeExpire = (dateNumber = 30, hour = 24) => {
  const date = new Date().getTime();
  return Math.floor(date / 1000) + dateNumber * 60 * 60 * hour ;
};

/**
 *
 * @param phone
 */
$.convertPhone = (phone) => {
  if (phone.startsWith("+84")) {
    phone.replace(/[+]{1}84/i, "0");
  } else if (phone.startsWith("84")) {
    phone.replace(/84/i, "0");
  } else if (!phone.startsWith("0")) {
    phone = "0" + phone;
  }
  return phone;
};

$.genTokenVerify = (data) => {
  try {
    const date = new Date().getTime();
    const token = btoa(`${date} ${$.makeId(5)}`);
    rdSet(token, data, 60 * 10);
    return token;
  } catch (error) {
    throw new Error("save token to redis error");
  }
};
global.$  = $
export  {$}
